{"type":"code","name":"SDG - SMOTE Synthetic Data Generation.step","displayName":"SDG - SMOTE Synthetic Data Generation.step","description":"","templates":{"SAS":"/*-----------------------------------------------------------------------------------------*\n   DEBUG Section\n   Code under the debug section SHOULD ALWAYS remain commented unless you are tinkering with  \n   or testing the step!\n*------------------------------------------------------------------------------------------*/\n\n/* Provide test values for the parameters */\n\n/*\n%let CLASSTOAUGMENT =1;\n%let CLASSVAR =BAD;\n%let CLASSVAR_1_TYPE =Numeric;\n%let INPUTTABLE =PUBLIC.HMEQ;\n%let INPUTTABLE_ENGINE=V9;\n%let INPUTTABLE_LIB=PUBLIC;\n%let INPUTTABLE_NAME=HMEQ;\n%let INPUTTABLE_NAME_BASE=HMEQ;\n%let INPUTTABLE_TBLTYPE=table;\n%let INPUTTABLE_TYPE=dataTable;\n%let INPUTVARS=BAD LOAN MORTDUE VALUE REASON JOB YOJ DEROG DELINQ CLAGE NINQ CLNO DEBTINC;\n%let NOMINALVARS=BAD REASON JOB;\n%let NOMINALVARS_COUNT=3;\n%let CLASSVAR_COUNT=1;\n%let NUMK=5;\n%let NUMSAMPLES=100;\n%let NUMTHREADS=0;\n%let OUTPUTTABLE=PUBLIC.HMEQ_SYNTH;\n%let OUTPUTTABLE_ENGINE=V9;\n%let OUTPUTTABLE_LIB=PUBLIC;\n%let OUTPUTTABLE_NAME=HMEQ_SYNTH;\n%let OUTPUTTABLE_NAME_BASE=HMEQ_SYNTH;\n%let SEEDNUMBER=123;\n%let extrapolationFactor=0;\n\n*/;\n\n/*-----------------------------------------------------------------------------------------*\n   END DEBUG Section\n*------------------------------------------------------------------------------------------*/\n\n\n/*-----------------------------------------------------------------------------------------*\n   MACROS\n*------------------------------------------------------------------------------------------*/\n\n\n/* -------------------------------------------------------------------------------------------* \n   Macro to initialize a run-time trigger global macro variable to run SAS Studio Custom Steps. \n   A value of 1 (the default) enables this custom step to run.  A value of 0 (provided by \n   upstream code) sets this to disabled.\n\n   Input:\n   1. triggerName: The name of the runtime trigger you wish to create. Ensure you provide a \n      unique value to this parameter since it will be declared as a global variable.\n\n   Output:\n   2. &triggerName : A global variable which takes the name provided to triggerName.\n*-------------------------------------------------------------------------------------------- */\n\n%macro _create_runtime_trigger(triggerName);\n\n   %global &triggerName.;\n\n   %if %sysevalf(%superq(&triggerName.)=, boolean)  %then %do;\n  \n      %put NOTE: Trigger macro variable &triggerName. does not exist. Creating it now.;\n      %let &triggerName.=1;\n\n   %end;\n\n%mend _create_runtime_trigger;\n\n\n/* -----------------------------------------------------------------------------------------* \n   Macro to create an error flag for capture during code execution.\n\n   Input:\n      1. errorFlagName: The name of the error flag you wish to create. Ensure you provide a \n         unique value to this parameter since it will be declared as a global variable.\n      2. errorFlagDesc: A description to add to the error flag.\n\n    Output:\n      1. &errorFlagName : A global variable which takes the name provided to errorFlagName.\n      2. &errorFlagDesc : A global variable which takes the name provided to errorFlagDesc.\n*------------------------------------------------------------------------------------------ */\n\n%macro _create_error_flag(errorFlagName, errorFlagDesc);\n\n   %global &errorFlagName.;\n   %let  &errorFlagName.=0;\n   %global &errorFlagDesc.;\n\n%mend _create_error_flag;\n\n\n/*-----------------------------------------------------------------------------------------*\n   Macro to capture indicator and UUIDof any currently active CAS session.\n   UUID is not expensive and can be used in future to consider graceful reconnect.\n\n   Input:\n   1. errorFlagName: name of an error flag that gets populated in case the connection is \n                     not active. Provide this value in quotes when executing the macro.\n                     Define this as a global macro variable in order to use downstream.\n   2. errorFlagDesc: Name of a macro variable which can hold a descriptive message output\n                     from the check.\n                     \n   Output:\n   1. Informational note as required. We explicitly don't provide an error note since \n      there is an easy recourse(of being able to connect to CAS)\n   2. UUID of the session: macro variable which gets created if a session exists.\n   3. errorFlagName: populated\n   4. errorFlagDesc: populated\n*------------------------------------------------------------------------------------------*/\n\n%macro _env_cas_checkSession(errorFlagName, errorFlagDesc);\n\n    %if %sysfunc(symexist(_current_uuid_)) %then %do;\n       %symdel _current_uuid_;\n    %end;\n    %if %sysfunc(symexist(_SESSREF_)) %then %do;\n      %let casSessionExists= %sysfunc(sessfound(&_SESSREF_.));\n      %if &casSessionExists.=1 %then %do;\n         %global _current_uuid_;\n         %let _current_uuid_=;   \n         proc cas;\n            session.sessionId result = sessresults;\n            call symputx(\"_current_uuid_\", sessresults[1]);\n         quit;\n         %put NOTE: A CAS session &_SESSREF_. is currently active with UUID &_current_uuid_. ;\n         data _null_;\n            call symputx(&errorFlagName., 0);\n            call symput(&errorFlagDesc., \"CAS session is active.\");\n         run;\n      %end;\n      %else %do;\n         %put NOTE: Unable to find a currently active CAS session. Reconnect or connect to a CAS session upstream. ;\n         data _null_;\n            call symputx(&errorFlagName., 1);\n            call symput(&errorFlagDesc., \"Unable to find a currently active CAS session. Reconnect or connect to a CAS session upstream.\");\n        run;\n      %end;\n   %end;\n   %else %do;\n      %put NOTE: No active CAS session ;\n      data _null_;\n        call symputx(&errorFlagName., 1);\n        call symput(&errorFlagDesc., \"No active CAS session. Connect to a CAS session upstream.\");\n      run;\n   %end;\n\n%mend _env_cas_checkSession;   \n   \n\n/*-----------------------------------------------------------------------------------------*\n   Caslib for a Libname macro\n   \n   This macro creates a global macro variable called _usr_nameCaslib\n   that contains the caslib name (aka. caslib-reference-name) associated with the libname\n   and assumes that the libname is using the CAS engine.\n \n   As sysvalue has a length of 1024 chars, we use the trimmed option in proc sql\n   to remove leading and trailing blanks in the caslib name.\n   \n   From macro provided by Wilbram Hazejager (wilbram.hazejager@sas.com)\n\n   Inputs:\n   - _usr_LibrefUsingCasEngine : A library reference provided by the user which is based \n                                 on a CAS engine.\n   \n   Outputs:\n   - _usr_nameCaslib : Global macro variable containing the caslib name.\n*------------------------------------------------------------------------------------------*/\n \n%macro _usr_getNameCaslib(_usr_LibrefUsingCasEngine);\n \n   %global _usr_nameCaslib;\n   %let _usr_nameCaslib=;\n \n   proc sql noprint;\n      select sysvalue into :_usr_nameCaslib trimmed from dictionary.libnames\n      where libname = upcase(\"&_usr_LibrefUsingCasEngine.\") and upcase(sysname)=\"CASLIB\";\n   quit;\n\n   /*--------------------------------------------------------------------------------------*\n      Note that we output a NOTE instead of an ERROR for the below condition since the \n      execution context determines whether this is an error or just an informational note.\n   *---------------------------------------------------------------------------------------*/\n   %if \"&_usr_nameCaslib.\" = \"\" %then %put NOTE: The caslib name for the &_usr_LibrefUsingCasEngine. is blank.;\n \n%mend _usr_getNameCaslib;\n\n\n/*-----------------------------------------------------------------------------------------*\n   Macro to check if a given libref belongs to a SAS or CAS engine.\n\n   Input:\n   1. sasCasLibref: a libref to be checked. Do not quote.\n   2. tableEngine: a flag to hold the table Engine value.\n   3. errorFlagName: a flag to populate an error code with.\n   4. errorFlagDesc: a flag to describe the error if one occurs.\n   5. sessionExists: an indicator (1) whether an active CAS session exists.  If not(0),\n                     it will be created.\n                     \n   Output:\n   1. tableEngine: populated with SAS or CAS\n   2. errorFlagName: populated with 1 if an error and 0 if not\n   3. errorFlagDesc: populated in case of an error\n*------------------------------------------------------------------------------------------*/\n\n%macro _sas_or_cas(sasCasLibref, tableEngine, errorFlagName, errorFlagDesc, sessionExists);\n\n   %if &sessionExists. = 0 %then %do;\n      cas _temp_ss_ ;\n      caslib _ALL_ assign;\n   %end;\n\n    proc sql noprint;\n        select distinct Engine into:&&tableEngine. from dictionary.libnames where libname = upcase(\"&sasCasLibref.\");\n    quit;\n\n    %put \"&&&tableEngine.\";\n\n    %if %sysfunc(compress(\"&&&tableEngine.\")) = \"V9\" %THEN %DO;\n        data _null_;\n            call symput(\"&tableEngine.\",\"SAS\");\n            call symputx(\"&errorFlag.\",0);\n            call symput(\"&errorFlagDesc.\",\"\");\n        run;\n    %end;\n    %else %if %sysfunc(compress(\"&&&tableEngine.\")) = \"CAS\" %THEN %DO;\n        data _null_;\n            call symputx(\"&errorFlagName.\",0);\n            call symput(\"&errorFlagDesc.\",\"\");\n        run;\n    %END;\n    %else %do;\n        data _null_;\n            call symputx(\"&errorFlagName.\",1);\n            call symput(\"&errorFlagDesc.\",\"Unable to associate libref with either SAS or CAS. Check the input libref provided.\");\n        run;\n    %end;\n\n   %if &sessionExists. = 0 %then %do;\n      cas _temp_ss_ terminate;\n   %end;\n    \n%mend _sas_or_cas;\n\n\n/*-----------------------------------------------------------------------------------------*\n   Macro to check if an in-memory table exists.\n\n   Input:\n   1. tableName: name of the in-memory table\n   2. tableLib: caslib backing the in-memory table\n   3. sessionExists: an indicator (1) whether an active CAS session exists.  If not(0),\n                     it will be created.\n                     \n   Output:\n   1. tableExists: populated with 0 if does not exist, 1 if exists with local scope, \n                   2 if exists with global scope\n\n*------------------------------------------------------------------------------------------*/   \n\n%macro _cas_table_exists(tableName, tableLib, sessionExists, tableExists);\n\n   %if &sessionExists. = 0 %then %do;\n      cas _temp_ss_ ;\n      caslib _ALL_ assign;\n   %end;\n\n   proc cas;\n      table.tableExists result = rc /\n         name=\"&tableName.\",\n         caslib=\"&tableLib.\"\n      ;\n      call symputx(\"&tableExists.\",rc.exists);\n   quit;\n\n   %if &sessionExists. = 0 %then %do;\n      cas _temp_ss_ terminate;\n   %end;\n    \n%mend _cas_table_exists;\n   \n\n/*-----------------------------------------------------------------------------------------*\n   EXECUTION CODE MACRO \n\n   _smt prefix stands for SMOTE\n*------------------------------------------------------------------------------------------*/\n\n%macro _smt_execution_code;\n\n/*-----------------------------------------------------------------------------------------*\n   Create an error flag. \n*------------------------------------------------------------------------------------------*/\n\n   %_create_error_flag(_smt_error_flag, _smt_error_desc);\n\n/*-----------------------------------------------------------------------------------------*\n   Check if an active CAS session exists. \n*------------------------------------------------------------------------------------------*/\n\n   %_env_cas_checkSession(\"_smt_error_flag\", \"_smt_error_desc\");\n\n/*-----------------------------------------------------------------------------------------*\n   Check Input table libref to ensure it points to a valid caslib.\n*------------------------------------------------------------------------------------------*/\n\n   %if &_smt_error_flag. = 0 %then %do;\n\n      %global inputCaslib;\n      %_usr_getNameCaslib(&inputTable_lib.);\n      %let inputCaslib=&_usr_nameCaslib.;\n      %put NOTE: &inputCaslib. is the caslib for the input table.;\n      %let _usr_nameCaslib=;\n\n      %if \"&inputCaslib.\" = \"\" %then %do;\n         data _null_;\n            call symputx(\"_smt_error_flag\",1);\n            call symput(\"_smt_error_desc\",\"ERROR: Input table caslib is blank. Check if Base table is a valid CAS table.\");\n         run;\n         %put ERROR: Input table caslib is blank. Check if Base table is a valid CAS table. ;\n      %end;\n\n   %end;\n\n/*-----------------------------------------------------------------------------------------*\n   Check if input table exists.\n*------------------------------------------------------------------------------------------*/\n   \n   %global casTableExists;\n\n   %if &_smt_error_flag. = 0 %then %do;\n      %_cas_table_exists(&inputTable_name_base.,&inputTable_lib.,1,casTableExists);\n      %if &casTableExists.=0 %then %do;\n         data _null_;\n            call symputx(\"_smt_error_flag\",1);\n            call symput(\"_smt_error_desc\",\"ERROR: The given CAS table does not seem to exist. Please check if it is loaded to CAS.\");\n         run;\n         %put ERROR: The given CAS table does not seem to exist. Please check if it is loaded to CAS.;\n      %end;    \n   %end;\n\n/*-----------------------------------------------------------------------------------------*\n   Check Output table libref to ensure it points to a valid caslib.\n*------------------------------------------------------------------------------------------*/\n\n   %if &_smt_error_flag. = 0 %then %do;\n\n      %global outputCaslib;\n      %_usr_getNameCaslib(&outputTable_lib.);\n      %let outputCaslib=&_usr_nameCaslib.;\n      %put NOTE: &outputCaslib. is the caslib for the output table.;\n      %let _usr_nameCaslib=;\n\n      %if \"&outputCaslib.\" = \"\" %then %do;\n         data _null_;\n            call symputx(\"_smt_error_flag\",1);\n            call symput(\"_smt_error_desc\",\"ERROR: Output table caslib is blank. Check if table is a valid CAS table.\");\n         run;\n         %put ERROR: Output table caslib is blank. Check if table is a valid CAS table. ;\n      %end;\n\n   %end;\n\n/*-----------------------------------------------------------------------------------------*\n   Obtain list of input & nominal variables and store them in macro variables.\n*------------------------------------------------------------------------------------------*/\n\n   %if &_smt_error_flag. = 0 %then %do;\n      %let blankSeparatedInputVars = %_flw_get_column_list(_flw_prefix=inputVars);\n      %let blankSeparatedNominalVars = %_flw_get_column_list(_flw_prefix=nominalVars);\n   %end;\n\n   %put NOTE: Input variables selected - &blankSeparatedInputVars.;\n   %put NOTE: Nominal variables selected - &blankSeparatedNominalVars.;\n\n\n/*-----------------------------------------------------------------------------------------*\n   Create a program string based on selection of nominal variables.\n*------------------------------------------------------------------------------------------*/\n\n   %if &_smt_error_flag. = 0 %then %do;\n      %if &nominalVars_count.=0 %then %do;\n         data _null_;\n            call symput(\"nominalString\",\"\");\n         run;\n      %end;\n      %else %do;\n         data _null_;\n            call symput(\"nominalString\",\"nominals=${&blankSeparatedNominalVars.},\");\n         run;\n      %end;\n   %end;\n\n/*-----------------------------------------------------------------------------------------*\n   Create a program string based on selection of class variables.\n*------------------------------------------------------------------------------------------*/\n   %if &_smt_error_flag. = 0 %then %do;\n      %if &classVar_count.=0 %then %do;\n         data _null_;\n            call symput(\"classString\",\"\");\n            call symput(\"classToAugment\",\"\");\n            call symput(\"classAugmentString\",\"\");\n         run;\n      %end;\n      %else %do;\n         data _null_;\n            call symput(\"classString\",\"classColumn=classColumnVar,\");\n            call symput(\"classAugmentString\",\"classToAugment=class_to_augment,\");\n         run;\n      %end;\n   %end;\n\n/*-----------------------------------------------------------------------------------------*\n   Run SMOTE action\n*------------------------------------------------------------------------------------------*/\n\n   %if &_smt_error_flag. = 0 %then %do;\n      proc cas;        \n         numK                      = symget(\"numK\");\n         inputTableCaslib          = symget(\"inputCaslib\");\n         inputTableName            = symget(\"inputTable_name_base\");\n         blankSeparatedNominalVars = symget(\"blankSeparatedNominalVars\");\n         blankSeparatedInputVars   = symget(\"blankSeparatedInputVars\");\n         classColumnVar            = symget(\"classVar\");\n         classVarType              = symget(\"classVar_1_Type\");\n         classToAugment            = symget(\"classToAugment\");\n         numSamplesVar             = symget(\"numSamples\");\n         outputTableCaslib         = symget(\"outputCaslib\");\n         outputTableName           = symget(\"outputTable_name_base\");\n         seedNumber                = symget(\"seedNumber\");\n         numThreads                = symget(\"numThreads\");\n         extrapolation_factor      = symget(\"extrapolationFactor\");\n\n         if classVarType = \"Numeric\" then class_to_augment = classToAugment*1; \n         else class_to_augment = classToAugment;\n\n         smote.smoteSample result=r/\n            table={name=inputTableName, caslib=inputTableCaslib},\n            k = numK,\n            inputs=${&blankSeparatedInputVars.},\n            &nominalString.\n            &classString.\n            &classAugmentString.\n            seed=seedNumber,\n            nThreads = numThreads,\n            numSamples=numSamplesVar,\n            extrapolationFactor=extrapolation_factor,\n            casout={name=outputTableName,caslib= outputTableCaslib, replace=\"TRUE\"}\n         ;\n         print r;\n      run;\n      quit;\n\n   %end;\n\n%mend _smt_execution_code;   \n\n/*-----------------------------------------------------------------------------------------*\n   END MACROS\n*------------------------------------------------------------------------------------------*/\n\n/*-----------------------------------------------------------------------------------------*\n   EXECUTION CODE\n*------------------------------------------------------------------------------------------*/\n   \n/*-----------------------------------------------------------------------------------------*\n   Create Runtime Trigger\n*------------------------------------------------------------------------------------------*/\n%_create_runtime_trigger(_smt_run_trigger);\n\n/*-----------------------------------------------------------------------------------------*\n   Execute \n*------------------------------------------------------------------------------------------*/\n\n%if &_smt_run_trigger. = 1 %then %do;\n\n   %_smt_execution_code;\n\n%end;\n\n%if &_smt_run_trigger. = 0 %then %do;\n\n   %put NOTE: This step has been disabled.  Nothing to do.;\n\n%end;\n\n\n%put NOTE: Final summary;\n%put NOTE: Status of error flag - &_smt_error_flag. ;\n%put &_smt_error_desc.;\n%put NOTE: Error desc - &_smt_error_desc. ;\n\n/*-----------------------------------------------------------------------------------------*\n   END EXECUTION CODE\n*------------------------------------------------------------------------------------------*/\n/*-----------------------------------------------------------------------------------------*\n   Clean up existing macro variables and macro definitions.\n*------------------------------------------------------------------------------------------*/\n\n%if %symexist(inputCaslib) %then %do;\n   %symdel inputCaslib;\n%end;\n\n%if %symexist(outputCaslib) %then %do;\n   %symdel outputCaslib;\n%end;\n\n%if %symexist(casTableExists) %then %do;\n   %symdel casTableExists;\n%end;\n\n%if %symexist(_smt_run_trigger) %then %do;\n   %symdel _smt_run_trigger;\n%end;\n\n%if %symexist(_smt_error_flag) %then %do;\n   %symdel _smt_error_flag;\n%end;\n\n%if %symexist(_smt_error_desc) %then %do;\n   %symdel _smt_error_desc;\n%end;\n\n%sysmacdelete _create_error_flag;\n%sysmacdelete _create_runtime_trigger;\n%sysmacdelete _env_cas_checkSession;\n%sysmacdelete _usr_getNameCaslib;\n%sysmacdelete _sas_or_cas;\n%sysmacdelete _cas_table_exists;\n%sysmacdelete _smt_execution_code;\n"},"properties":{},"ui":"{\n\t\"showPageContentOnly\": true,\n\t\"pages\": [\n\t\t{\n\t\t\t\"id\": \"page1\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Parameters\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section1\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Input Table\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"text2\",\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": \"Connect a SAS Cloud Analytics Services (CAS) table to the input port of this step.\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"inputTable\",\n\t\t\t\t\t\t\t\"type\": \"inputtable\",\n\t\t\t\t\t\t\t\"label\": \"Select input table:\",\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"parameters_section\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Parameters\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"numK\",\n\t\t\t\t\t\t\t\"type\": \"numstepper\",\n\t\t\t\t\t\t\t\"label\": \"Select number of nearest neighbors:\",\n\t\t\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\t\t\"integer\": true,\n\t\t\t\t\t\t\t\"min\": 1,\n\t\t\t\t\t\t\t\"max\": 1000,\n\t\t\t\t\t\t\t\"stepsize\": 1\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"inputVars\",\n\t\t\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\t\t\"label\": \"Select input columns:\",\n\t\t\t\t\t\t\t\"include\": null,\n\t\t\t\t\t\t\t\"order\": false,\n\t\t\t\t\t\t\t\"columntype\": \"a\",\n\t\t\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\t\t\"min\": 1,\n\t\t\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\t\t\"table\": \"inputTable\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"nominalVars\",\n\t\t\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\t\t\"label\": \"Select nominal columns:\",\n\t\t\t\t\t\t\t\"include\": \"inputVars\",\n\t\t\t\t\t\t\t\"order\": false,\n\t\t\t\t\t\t\t\"columntype\": \"a\",\n\t\t\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\t\t\"min\": 0,\n\t\t\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\t\t\"table\": null\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"classVar\",\n\t\t\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\t\t\"label\": \"Select a class column to augment:\",\n\t\t\t\t\t\t\t\"include\": \"inputVars\",\n\t\t\t\t\t\t\t\"order\": false,\n\t\t\t\t\t\t\t\"columntype\": \"a\",\n\t\t\t\t\t\t\t\"max\": 1,\n\t\t\t\t\t\t\t\"min\": 0,\n\t\t\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\t\t\"table\": null\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"classToAugment\",\n\t\t\t\t\t\t\t\"type\": \"dropdown\",\n\t\t\t\t\t\t\t\"label\": \"Select a class value to augment:\",\n\t\t\t\t\t\t\t\"items\": {\n\t\t\t\t\t\t\t\t\"ref\": \"classVar\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"visible\": \"$classVar\",\n\t\t\t\t\t\t\t\"enabled\": \"$classVar\",\n\t\t\t\t\t\t\t\"indent\": 1\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section9\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Output specification\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"numSamples\",\n\t\t\t\t\t\t\t\"type\": \"numberfield\",\n\t\t\t\t\t\t\t\"label\": \"Number of synthetic observations:\",\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\t\t\"min\": 10,\n\t\t\t\t\t\t\t\"excludemin\": false,\n\t\t\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\t\t\"integer\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"text1\",\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": \"Connect a SAS Cloud Analytics Services (CAS) table to the output port of this step.\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"outputTable\",\n\t\t\t\t\t\t\t\"type\": \"outputtable\",\n\t\t\t\t\t\t\t\"label\": \"Provide output table:\",\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"page2\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Configuration\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"numThreads\",\n\t\t\t\t\t\"type\": \"numstepper\",\n\t\t\t\t\t\"label\": \"Select number of threads:\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"integer\": true,\n\t\t\t\t\t\"min\": 0,\n\t\t\t\t\t\"max\": 1024,\n\t\t\t\t\t\"stepsize\": 1\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"seedNumber\",\n\t\t\t\t\t\"type\": \"numberfield\",\n\t\t\t\t\t\"label\": \"Select a seed:\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": null,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"extrapolationFactor\",\n\t\t\t\t\t\"type\": \"numberfield\",\n\t\t\t\t\t\"label\": \"Provide extrapolation factor (to perturb input data boundary):\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": 0,\n\t\t\t\t\t\"excludemin\": false,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"integer\": false\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"about\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"About\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"about_description\",\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"text\": \"Synthetic Minority Oversampling TEchnique (SMOTE) \\n=====================================\\n\\nThis custom step helps you generate synthetic data based on an input table, using the Synthetic Minority Oversampling TEchnique (SMOTE). SMOTE is an oversampling technique which identifies new data observations in the neighborhood of closely associated original observations. \\n\\nSMOTE is an alternative approach to Generative Adversarial Networks (GANs) for generating synthetic tabular data. Access to synthetic data helps you make better, data-informed decisions in situations where you have imbalanced, scant, poor quality, unobservable, or restricted data.\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section8\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Prerequisites\",\n\t\t\t\t\t\"open\": false,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"text4\",\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": \"1. A SAS Viya 4 environment, preferably monthly stable 2024.10 or later\\n\\n2. A Visual Data Mining and Machine Learning (VDMML) license, usually provided with SAS Viya, SAS Viya Enterprise or Advanced.\\n\\n3. An active SAS Cloud Analytics Services (CAS) connection during runtime.\\n\\n4. The smote.smoteSample CAS action requires Python configuration, as specified in SAS documentation. Please work with your SAS administrator to have the same configured. Specifically, ensure the following:\\n\\n    1. The correct version of Python is installed (as of version 2024.10, this was 3.11.x)  \\n   2. [sas-ipc-queue](https://pypi.org/project/sas-ipc-queue/) , version atleast 0.7.0 and beyond \\n   3. [hnswlib](https://pypi.org/project/hnswlib/)\\n   4. [protobuf](https://pypi.org/project/protobuf/)\\n\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section10\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Assumptions\",\n\t\t\t\t\t\"open\": false,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"text6\",\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": \"Current assumptions for this initial versions (future versions may improve upon the same):\\n\\n1. Users  choose either an existing Chroma DB vector database collection or load PDF or CSV files to an existing or new Chroma DB collection.\\n\\n2. Users may load all PDFs in a directory on the SAS Server (filesystem), or select a PDF / CSV of their choice.\\n\\n3. The code assumes use of a Chroma DB vector store.  Users may choose to replace this with other supported vector stores.\\n\\n4. The code uses the langchain LLM framework.  \\n\\n5. PDFs (containing text) and single CSV files are currently the only loadable file format allowed.  Users are however free to ingest various other document types into a Chroma DB collection beforehand, using the \\\"Vector Databases - Hydrate Chroma DB collection\\\" SAS Studio Custom Step (refer documentation)\\n\\n6. User has already configured Azure OpenAI to deploy both an embedding function and LLM service, or knows the deployment names. \\n\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"about_parameters\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Parameters\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"parameters_input\",\n\t\t\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\t\t\"label\": \"Input parameters\",\n\t\t\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"id\": \"input_parameters_text\",\n\t\t\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\t\t\"text\": \"1. Input table (input port, required): connect a CAS table to the input port.\\n\\n2. Nearest neighbors (numeric stepper, default 5): select the number of nearest neighbours to be used by the SMOTE algorithm as the basis for identifying candidate synthetic points.\\n\\n3. Input columns (column selector): select all inputs for the SMOTE process. You would also need to include the class and any nominal columns.\\n\\n4. Nominal variables (column selector): select any nominal variables you wish to use. Your nominal variables are required to be in the inputs column list.\\n\\n5. Select a class column (column selector, optional): select a column if you wish to use SMOTE in order to balance or augment a level within the class column. Be judicious in the choice of this column since a column with a high number of levels may slow down or even fail the process. Your class column is required to be in the inputs column list.\\n\\n6. Class to augment (drop-down list, values from class column if selected): select the level of the class variable you wish to augment. The values that appear here depend on the data that's contained in the class column, so may take time to populate based on actual data and number of levels.\",\n\t\t\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"parameters_output_specs\",\n\t\t\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\t\t\"label\": \"Output specifications\",\n\t\t\t\t\t\t\t\"open\": false,\n\t\t\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"id\": \"output_parameters_text\",\n\t\t\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\t\t\"text\": \"1. Number of synthetic observations (numeric field): specify the number of synthetic observations you would like in the output table.\\n\\n2. Output table (output port, option): attach a CAS table to the output port to hold results.\",\n\t\t\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"parameters_config_1\",\n\t\t\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\t\t\"label\": \"Configuration \",\n\t\t\t\t\t\t\t\"open\": 1,\n\t\t\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"id\": \"output_parameters_text_1\",\n\t\t\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\t\t\"text\": \"1. Number of threads: (numeric stepper, optional): most of the time, you do not need to modify this. Change if you need to especially control the number of threads in which the process runs.\\n\\n2. Select a seed (numeric field, optional): specify a seed number to establish (but not completely guarantee) some level of reproducability with respect to results.\\n\\n3. Select extrapolation factor: specify a number (double) to use as a standard deviation in order to perturb (add noise or randomness) the input data boundaries.\",\n\t\t\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"about_runtimecontrol\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Run-time Control\",\n\t\t\t\t\t\"open\": 0,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"runtimecontrol_text\",\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": \"Note: Run-time control is optional.  You may choose whether to execute the main code of this step or not, based on upstream conditions set by earlier SAS programs.  This includes nodes run prior to this custom step earlier in a SAS Studio Flow, or a previous program in the same session.\\n\\nRefer this blog (https://communities.sas.com/t5/SAS-Communities-Library/Switch-on-switch-off-run-time-control-of-SAS-Studio-Custom-Steps/ta-p/885526) for more details on the concept.\\n\\nThe following macro variable,\\n\\n_smt_run_trigger\\n\\nwill initialize with a value of 1 by default, indicating an \\\"enabled\\\" status and allowing the custom step to run.\\n\\nIf you wish to control execution of this custom step, include code in an upstream SAS program to set this variable to 0.  This \\\"disables\\\" execution of the custom step.\\n\\nTo \\\"disable\\\" this step, run the following code upstream:\\n\\n%global _smt_run_trigger;\\n%let _smt_run_trigger =0;\\n\\nTo \\\"enable\\\" this step again, run the following (it's assumed that this has already been set as a global variable):\\n\\n%let _smt_run_trigger =1;\\n\\nIMPORTANT: Be aware that disabling this step means that none of its main execution code will run, and any  downstream code which was dependent on this code may fail.  Change this setting only if it aligns with the objective of your SAS Studio program.\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"about_documentation\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Documentation\",\n\t\t\t\t\t\"open\": 0,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"documentation_text\",\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": \"1.  Documentation on the smote.smoteSample CAS action: https://go.documentation.sas.com/doc/en/pgmsascdc/default/casactml/casactml_smote_details01.htm\\n\\n2. PyPi page for sas-ipc-queue.  While an implementation detail for the smoteSample action, this is a good place to highlight efficient memory handling techniques, for interested programmers: https://pypi.org/project/sas-ipc-queue/\\n\\n3. PyPi page for hnswlib, an algorithm for fast approximate nearest neighbour search, used in smoteSample: https://pypi.org/project/hnswlib/\\n\\n4. PyPi page for protobuf (Python package used within action): https://pypi.org/project/protobuf/\\n\\n\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"version_text\",\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"text\": \"Version: 1.1  (28OCT2024)\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"contact_text\",\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"text\": \"Created/contact: \\n\\n- Sundaresh Sankaran (sundaresh.sankaran@sas.com)\\n\\nAcknowledgements to others for their help on details, testing or exploring the area: \\n- David Olaleye (david.olaleye@sas.com)\\n- Suneel Grover (suneel.grover@sas.com)\\n- Reza Nazari (reza.nazari@sas.com)\\n- SAS Analytics R&D team\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t],\n\t\"syntaxversion\": \"1.3.0\",\n\t\"values\": {\n\t\t\"inputTable\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"numK\": 5,\n\t\t\"inputVars\": [],\n\t\t\"nominalVars\": [],\n\t\t\"classVar\": [],\n\t\t\"classToAugment\": null,\n\t\t\"numSamples\": 100,\n\t\t\"outputTable\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"numThreads\": 0,\n\t\t\"seedNumber\": 123,\n\t\t\"extrapolationFactor\": 0\n\t}\n}","flowMetadata":{"inputPorts":[{"name":"inputTable","displayName":"inputTable","minEntries":1,"maxEntries":1,"type":"table"}],"outputPorts":[{"name":"outputTable","displayName":"outputTable","minEntries":1,"maxEntries":1,"columnDelta":null,"type":"table"}]}}